Index: lib/bb/cooker.py
===================================================================
--- lib/bb/cooker.py.orig
+++ lib/bb/cooker.py
@@ -735,6 +735,54 @@ class BBCooker:
 
         self.server_registration_cb(buildTargetsIdle, rq)
 
+    def findDups(self):
+        ignores = bb.data.getVar("PKGDUP_IGNORES", self.configuration.data, 1) or ""
+        ignores = dict(map(lambda x: (x,0), ignores.split()))
+
+        dupes   = {}
+        scm_suf = re.compile('.*[-+_](svn|cvs|git|hg)\\.bb$')
+
+        for (pn,fns) in self.status.pkg_pn.items():
+            if len(fns) <= 1:
+                continue
+
+            tmp = []
+            for f in fns:
+                if f.startswith('virtual:') or scm_suf.match(f):
+                    continue
+
+                pepvpr = self.status.pkg_pepvpr[f]
+                label  = "%s:%s-%s" % pepvpr
+                bname  = os.path.basename(f).rstrip('.bb')
+
+                if ignores.has_key(bname):
+                    ignores[bname] = 1
+                    continue
+
+                tmp.append([pepvpr, label, f])
+
+            if len(tmp) <= 1:
+                continue
+
+            assert not dupes.has_key(pn)
+            dupes[pn] = tmp
+
+        dmap = dupes.items()
+        dmap.sort(cmp = (lambda x,y: cmp(x[0], y[0])))
+
+        for (pn, entries) in dmap:
+            entries.sort(cmp = (lambda x,y: utils.vercmp(x[0], y[0])))
+
+            print(pn + '(' + (", ".join(map(lambda x: x[1], entries))) + ')')
+
+            for e in entries:
+                print("    " + e[2])
+
+        eignores = filter(lambda (x,y): y == 0, ignores.items())
+        for i in eignores:
+            bb.msg.warn(bb.msg.domain.Collection,
+                        "unused '%s' pkgdup ignore" % i[0])
+
     def updateCache(self):
         if self.state == state.running:
             return
@@ -777,6 +825,10 @@ class BBCooker:
 
         if not self.parser.parse_next():
             collectlog.debug(1, "parsing complete")
+
+            if bb.msg.debug_level[bb.msg.domain.Collection] >= 1:
+                self.findDups()
+
             self.buildDepgraph()
             self.state = state.running
             return None
