#! /bin/bash

set -e
P=$1

: ${GIT:=git}

apply() {
    test -e "$1/bundle" || return 0

    read dir < "$1"/dir

    cd "$dir"

    case x`$GIT config core.bare` in
      (xtrue)	is_bare=true ;;
      (*)	is_bare=false ;;
    esac

    cur_head=
    cur_head_ref=
    if ! $is_bare; then
	if ! $GIT symbolic-ref HEAD 2>/dev/null; then
	    is_dirty_head=true
	else
	    is_dirty_head=false
	    cur_head=`$GIT symbolic-ref HEAD`
	    cur_head_ref=`$GIT ls-remote . "$cur_head" | \
                      sed '1s/[[:blank:]].*//p;d'`
	fi
    fi

    $GIT bundle verify $1/bundle &>/dev/null

    $GIT ls-remote $1/bundle | while read ref branch; do
	if test x"$cur_head" = x"$branch"; then
	    $GIT pull "$1/bundle" "$branch"
	else
	    $GIT fetch "$1/bundle" "$branch:$branch" ||
	    $GIT fetch "$1/bundle" "+$branch:refs/failed/${branch##refs/heads/}"
	fi
    done
}

t=$(mktemp -t -d update-pack.XXXXXX)
trap "rm -rf $t" EXIT

tar xf "$P" -C $t

for i in $t/*; do
    test -d "$i" || continue

    ( apply "$i" )
done
