#! /bin/bash

set -e
P=$1

API=1

: ${GIT:=git}

apply() {
    is_new=false
    test -e "$1/bundle" || return 0

    read dir < "$1"/dir

    if ! test -d "$dir" || test x"$dir" = x. -a ! -d "$dir/.git"; then
	opts=
	! test -e "$1"/bare || opts="$opts --bare"

	$GIT init $opts $dir
	is_new=true
    fi

    cd "$dir"

    case x`$GIT config core.bare` in
      (xtrue)	is_bare=true ;;
      (*)	is_bare=false ;;
    esac

    cur_head=
    cur_head_ref=
    if ! $is_bare; then
	if ! $GIT symbolic-ref HEAD 2>/dev/null; then
	    is_dirty_head=true
	else
	    is_dirty_head=false
	    cur_head=`$GIT symbolic-ref HEAD`
	    cur_head_ref=`$GIT ls-remote . "$cur_head" | \
                      sed '1s/[[:blank:]].*//p;d'`
	fi
    fi

    $GIT bundle verify $1/bundle &>/dev/null

    $GIT ls-remote $1/bundle | while read ref branch; do
	fail_fetch=+$branch:refs/heads/failed/${branch##refs/heads/}
	if test x"$cur_head" = x"$branch"; then
	    $GIT pull "$1/bundle" "$branch" || \
	    $GIT fetch "$1/bundle" "$fail_fetch"
	else
	    $GIT fetch "$1/bundle" "$branch:$branch" || \
	    $GIT fetch "$1/bundle" "$fail_fetch"
	fi

	if $is_new && ! $is_bare; then
	    $GIT checkout "${branch##refs/heads/}"
	    is_new=false
	fi
    done

    while read ref branch; do
	case $branch in
	  (refs/heads/*)
		$GIT branch "${branch##refs/heads/}" "$ref" 2>/dev/null || :
		;;
	esac
    done < $1/branches
}

t=$(mktemp -t -d update-pack.XXXXXX)
trap "rm -rf $t" EXIT

tar xf "$P" -C $t

read api < $t/api &>/dev/null || api=0
test "$API" -ge "$api" || {
  echo "apply-update-pack is too old (api $api requested, api $API available)" >&2
  exit 1
}

for i in $t/*; do
    test -d "$i" || continue

    ( apply "$i" )
done

$GIT submodule init

$GIT submodule status --cached | while read ref dir xtra; do
    case $ref in
      (+*)
	    ( cd "$dir" && $GIT checkout ${ref##+} )
	    ;;
    esac
done
