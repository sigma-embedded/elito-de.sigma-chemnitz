#!/usr/bin/env ruby

require "getoptlong"
require "rexml/document"

# defs
def defs
	bfs= 10; bfs_crop= 0.8
	@design = {:y_height => bfs, :y_margin => 2, :fontsize => "#{bfs}px", :t_fontsize => "#{bfs * bfs_crop}px", \
			:min_width => 1, :tx_offset => 100}
	@design[:t_boxpadding] = @design[:y_height] - (bfs * bfs_crop)
end
@design = {}; defs

# HTML Converter
class HTML
	SPACE_BETWEEN_LINES = 30

	def initialize
		clear
		clear_offset
		set_lineheight(0)
		set_fontsize(0)
	end

	def clear
		@data = []
		@width = 0
		@height = 0
	end

	def clear_offset
		@h_offset = 0
	end

	def set_lineheight(i)
		@lineheight = i.to_i
	end

	def set_fontsize(i)
		@fontsize = i.to_i
	end

	def a(*d)
		c_width= d[1][:x].to_f + d[1][:width].to_f
		c_height= d[1][:y].to_f + @lineheight.to_f
		@width= c_width.ceil if @width < c_width.to_f
		@height= c_height.ceil if @height < c_height.to_f

		@data << d
	end

	def title(text, o={})
		a(:title, o.merge({:height => SPACE_BETWEEN_LINES * 2}), text)
	end

	def stitle(text, o={})
		a(:title, o.merge({:height => SPACE_BETWEEN_LINES / 2}), text)
	end

	def textbox(x, y, w, text=nil, text2=nil, o={})
		a(:div, o.merge({:x => x, :y => y, :width => w}), text, text2)
	end

	def p(txt); @f.puts txt; end
	def write(fname, pagewidth_limit= 0)
		write_open(fname, pagewidth_limit)
		do_write_head
		do_write_data
		do_write_close
		write_close
	end

	def write_open(fname, pagewidth_limit= 0)
		@fwl= pagewidth_limit.to_i
		@f = ((fname == "-") ? $stdout : File.new(fname, "w"))
	end

	def write_close
		@f.close() if @f != "-"
		@f = nil
	end

	def transform_xyw(x, y, w)
		return [[x, y, w]] if @fwl == 0

		pos= []
		((x/@fwl).floor..((x+w)/@fwl).floor).to_a.each {|i|
			_x= x % @fwl; x= 0
			_w= (((_x + w) > @fwl) ? @fwl - _x : w); w -= _w
			next if _w == 0
			pos << [_x.to_i, (y + (i * @height) + @h_offset), _w.to_i]
		}

		return pos
	end

	def do_write_head
		p("<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'")
		p("\t'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>")
		p("<html xmlns='http://www.w3.org/1999/xhtml'>")
		p("<head><title>Generated by convert-mertrics</title>")
		p("<meta http-equiv='Content-Type' content='text/html;charset=UTF-8' />")
		p("<style type='text/css' media='screen'>")
		p("hr { position:absolute; color: blue; background-color: blue; left:0px; height: 5px; width: #{@fwl}px;")
		p("		margin: 0; padding: 0; border: 0px; -webkit-margin-before: 0px; -webkit-margin-after: 0px; }")
		p("h1 { margin: 0; text-align: center; white-space: nowrap; }")
		raise "lineheight is missing" if @lineheight.to_i == 0
		raise "fontsize is missing" if @fontsize.to_i == 0
		p("div { position:absolute; white-space: nowrap; font-family: Arial; font-size:#{@fontsize}px; ")
		p("		height: #{@lineheight}px; }")
		p("div.metric div { width:100%; height:100%; overflow: hidden; background-color: white; border:black solid 1px;}")
		p("div.status_ok div { background-color:lightgreen; }")
		p("div.status_fail div { background-color:#c00000; color: #ffffff;}")
		p("div.metric { }")
		p("div.metric:hover { }")
		p("div.metric span { visibility: hidden; position: absolute; left: 2em; margin-top: 1em; padding: 1em; }")
		p("div.metric:hover span { visibility: visible; border: 1px solid #347BEE; ")
		p("		color: #000000; background: #FFFFFF; z-index: 5;}")
		p("td { white-space: nowrap; font-family: Arial; }")
		p("th { white-space: nowrap; text-align: left; font-family: Arial; }")
		p("</style></head><body>")
	end

	def do_write_data
		@height += SPACE_BETWEEN_LINES if @fwl > 0

		@data.each {|d|
			case d[0]
			when :title
				x, y, w = transform_xyw(0, 0, @fwl)[0]
				s = ["left:#{x}px", "top:#{y}px", "width:#{w}px", "height:#{d[1][:height]}px"]
				ss = ["line-height: #{d[1][:height]}px", "font-size: #{d[1][:height] * 0.75}px"]
				p("<div style='#{s.join("; ")}'><h1 style='#{ss.join("; ")}'>#{d[2]}</h1></div>")
				@h_offset += d[1][:height]
			when :div
				transform_xyw(d[1][:x], d[1][:y], d[1][:width]).each {|x, y, w|
					s = ["left:#{x}px", "top:#{y}px", "width:#{w}px"]
					c= ["metric"]
					d[1].each {|k,v| next if k.class != String
						(c << v.downcase; next) if k == "class"
						s << "#{k}:#{v}"
					} 

					p("<div class='#{c.join(" ")}' style='#{s.join("; ")}'>")
					p("<div>#{d[2].gsub("\n", "<br/>")}</div>") if d[2].to_s != ""
					p("<span>#{d[3]}</span>") if d[3].to_s != ""
					p("</div>")
				}
			else
				$stderr.puts "skipped #{d}"
			end
		}

		i = 0; (1..((@width / @fwl) + 1)).to_a.each {|j| i = j
			p("<hr style='top:#{(@h_offset + @height * i) - (SPACE_BETWEEN_LINES / 2)}px;' />")
		}
		p("<hr style='top:#{(@h_offset + @height * i) - (SPACE_BETWEEN_LINES / 6)}px;' />")

		@h_offset += (@height * (@width / @fwl.to_f).ceil)
		@height -= SPACE_BETWEEN_LINES if @fwl > 0
	end

	def do_write_close
		p("</body></html>")
	end
end

#methods

@available_format = ["html"]
@params = {:format => @available_format.first}
def usage(msg= "")
	$stderr.puts "usage: #{$0} [options] <ifname> <ofname>"
	$stderr.puts "\t-h, --help		shows this message"
#	$stderr.puts "\t-f, --format [type]	select output format [available #{@available_format.join(", ")}]"
	$stderr.puts "\t-l, --limit [size]	limits the pagewidth"
	$stderr.puts msg if msg.to_s != ""
	exit(msg.to_s != "")
end

def pars_parameter
	opts = GetoptLong.new(
		[ "--help", "-h", GetoptLong::NO_ARGUMENT ],
		[ "--format", "-f", GetoptLong::REQUIRED_ARGUMENT ],
		[ "--limit", "-l", GetoptLong::REQUIRED_ARGUMENT ],
	)

	begin
		opts.each do |opt, arg|
			case opt
				when "--help"	then usage
				when "--format"
					usage("unknown format #{arg}") if not @available_format.include?(arg)
					@params[:format] = arg.to_s
				when "--limit"	then @params[:pagewidth_limit] = arg.to_i
			end
		end
	rescue => err
		usage("#{err.class()}: #{err.message}")
	end

	usage("Too many parameters") if ARGV.size > 2

	@params[:finame] = ((ARGV.size < 1) ? "-" : ARGV[0])
	@params[:foname] = ((ARGV.size < 2) ? "-" : ARGV[1])
end

def select_former(format)
	case format
		when "html"	then return HTML.new
		else raise "unknown format '#{format}'"
	end
end


@builds = []
def load_metrics(fname)
	fin = ((fname == "-") ? $stdin : File.new(fname, "r"))
	fin_data = fin.readlines
	fin_data = "<root>#{fin_data.join("")}</root>"
	fin.close() if fname != "-"

	doc = REXML::Document.new(fin_data)

	doc.elements.each("*/build") { |tasks| tas = tasks.attributes
		m= {:all => [], :mvls => {:min => nil, :max => nil, :smdiff => nil, :resources => []}, :desc => {}}

		m[:desc][:project] = tas['project']
		m[:desc][:started_t] = Time.at((m[:desc][:started] = tas['started'].to_f))
		m[:desc][:ended_t] = Time.at((m[:desc][:ended] = tas['finished'].to_f))
		m[:desc][:duration] = tas['duration'].to_f

		tasks.elements.each("task") { |task| ta= task.attributes
			o = {}
			o[:pn] = ta['pn']
			o[:name] = ta['name']
			o[:version] = "#{ta['pv']} #{ta['pr']}"
			o[:status] = ta['result']

			o[:started_t] = Time.at((o[:started] = ta['started'].to_f))
			o[:ended_t] = Time.at((o[:ended] = ta['ended'].to_f))
			o[:duration] = ta['duration'].to_f
			
			o[:usage] = {}

			task.elements.each() {|t_sk| next if t_sk.name != "resource"
				t_ = t_sk.attributes
				o[:usage][t_['who'].to_sym] = {} if o[:usage][t_['who'].to_sym].nil?
				o[:usage][t_['who'].to_sym][t_['id'].to_sym] = t_sk.text
				m[:mvls][:resources] << t_['id'].to_sym if not m[:mvls][:resources].include?(t_['id'].to_sym)
			}

			m[:all] << o

			m[:mvls][:min] = o[:started] if m[:mvls][:min].nil? or m[:mvls][:min] > o[:started]
			m[:mvls][:max] = o[:ended]   if m[:mvls][:max].nil? or m[:mvls][:max] < o[:ended]

			diff= o[:ended] - o[:started]
			m[:mvls][:smdiff]= diff if m[:mvls][:smdiff].nil? or (m[:mvls][:smdiff] > diff and diff != 0.0)
		}
		m[:mvls][:factor] = @design[:min_width] / m[:mvls][:smdiff]
		@builds << m
	}
end

def h_timefmt(time)
	return "#{time.strftime("%d.%m.%Y %H:%M:%S")}.#{sprintf("%02i", (time.usec / 10000.0).ceil)}"
end

def gen_details(task, mvls)
	raise "Only support 'html' from get_details" if @params[:format] != "html"

	details= ""
	details += "<object><table>"
	{"Name" => :pn, "Task" => :name, "Version" => :version, "Status" => :status}.each {|k, v|
		details += "<tr><th>#{k}:</th><td>#{task[v]}</td></tr>"
	}

	{"Started" => :started_t, "Ended" => :ended_t}.each {|k, v|
		details += "<tr><th>#{k}:</td><td>#{h_timefmt(task[v])}</td></tr>"
	}
	details += "<tr><th>Duration:</td><td>#{sprintf("%.4f", task[:duration].to_f)}s</td></tr>"
	details += "</table></object><br/><br/>"
	details += "<object><table>"
	{:Usage => nil, "Children" => task[:usage][:children], "Self" => task[:usage][:self]}.each {|l, v|
		details += "<tr><th>#{l}:</td>"
		mvls[:resources].each {|r|
			details += ((v.nil?) ? "<th>#{r.to_s}</th>" : "<td>#{v[r]}</td>")
		}
		details += "</tr>"
	}
	details += "</table></object>"

	return details
end

def display_proc(former, tasks, mvls, y, inc_parent= false)
	register = [0]
	ipf = (inc_parent ? 2 : 1)

	tasks.each {|task|
		ureg= register.size 
		register.each_with_index {|reg, i|
			(ureg= i; break) if reg < task[:started]
		}

		tx = (@params[:details] ? @design[:tx_offset] : 0) + ((task[:started] - mvls[:min]) * mvls[:factor])
		ty = y + (ureg * ipf * (@design[:y_height] + @design[:y_margin]))
		wth = (task[:ended] - task[:started]) * mvls[:factor]

		former.textbox(tx, ty, wth, "#{task[:pn]}\n#{task[:name]}", \
				gen_details(task, mvls), {"class" => "status_#{task[:status]}"})

		register[ureg] = task[:ended]
	}

	return register.size * ipf
end

#main
pars_parameter
former = select_former(@params[:format])
load_metrics(@params[:finame])

former.set_lineheight(@design[:y_height] * 2)
former.set_fontsize(@design[:t_fontsize])

former.write_open(@params[:foname], @params[:pagewidth_limit])
former.do_write_head
@builds.each {|metrics|
	d= metrics[:desc]
	former.title(d[:project])
	former.stitle("Started: #{h_timefmt(d[:started_t])} Finished: #{h_timefmt(d[:ended_t])}")

	sort = metrics[:all].sort{|a,b| a[:started] <=> b[:started]}
	display_proc(former, sort, metrics[:mvls], 0, true)

	former.do_write_data
	former.clear
}
former.do_write_close
former.write_close
