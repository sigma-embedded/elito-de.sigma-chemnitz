#!/usr/bin/env ruby

require "getoptlong"
require "rexml/document"

# defs
def defs
	bfs= 10; bfs_crop= 0.8
	@design = {:y_height => bfs, :y_margin => 2, :fontsize => "#{bfs}px", :t_fontsize => "#{bfs * bfs_crop}px", \
			:min_width => 1, :tx_offset => 100}
	@design[:t_boxpadding] = @design[:y_height] - (bfs * bfs_crop)
end
@design = {}; defs

# HTML Converter
class HTML
	SPACE_BETWEEN_LINES = 30

	def initialize
		clear
		clear_offset
	end

	def clear
		@data = []
		@width = 0
		@height = 0
	end

	def clear_offset
		@h_offset = 0
	end

	def a(*d)
		c_width= d[1][:x].to_f + d[1][:width].to_f
		c_height= d[1][:y].to_f + d[1][:height].to_f
		@width= c_width.ceil if @width < c_width.to_f
		@height= c_height.ceil if @height < c_height.to_f

		@data << d
	end

	def title(text, o={})
		a(:title, o.merge({:height => SPACE_BETWEEN_LINES * 2}), text)
	end

	def stitle(text, o={})
		a(:title, o.merge({:height => SPACE_BETWEEN_LINES / 2}), text)
	end

	def btext(x, y, w, h, fs, text, o={})
		text(x, y, w, h, fs, text, {"font-weight" => "bold"})
	end

	def text(x, y, w, h, fs, text, o={})
		o["font-family"]= "Arial" if o[:font].nil?
		a(:text, o.merge({:x => x, :y => y, :width => w, :height => h, "font-size" => fs}), text)
	end

	def rect(x, y, w, h, o = {})
		a(:rect, o.merge({:x => x, :y => y, :width => w, :height => h}))
	end

	def box(x, y, w, h)
		rect(x, y, w, h, {:fill => "white", :stroke => "black", "stroke-width" => "1px"})
	end

	def textbox(x, y, w, h, fs, text=nil, text2=nil, o={})
		o["font-family"]= "Arial" if o[:font].nil?
		o= o.merge({:fill => "white", :stroke => "black", "stroke-width" => "1px"})
		a(:div, o.merge({:x => x, :y => y, :width => w, :height => h, "font-size" => fs}), text, text2)
	end

	def p(txt); @f.puts txt; end
	def write(fname, pagewidth_limit= 0)
		write_open(fname, pagewidth_limit)
		do_write_head
		do_write_data
		do_write_close
		write_close
	end

	def write_open(fname, pagewidth_limit= 0)
		@fwl= pagewidth_limit.to_i
		@f = ((fname == "-") ? $stdout : File.new(fname, "w"))
	end

	def write_close
		@f.close() if @f != "-"
		@f = nil
	end

	def transform_xywh(x, y, w, h)
		return [[x, y, w, h]] if @fwl == 0

		pos= []
		((x/@fwl).floor..((x+w)/@fwl).floor).to_a.each {|i|
			_x= x % @fwl; x= 0
			_w= (((_x + w) > @fwl) ? @fwl - _x : w); w -= _w
			next if _w == 0
			pos << [_x, (y + (i * @height) + @h_offset), _w, h]
		}

		return pos
	end

	def do_write_head
		p("<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'")
		p("\t'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>")
		p("<html xmlns='http://www.w3.org/1999/xhtml'>")
		p("<head><title>Generated by convert-mertrics</title>")
		p("<meta http-equiv='Content-Type' content='text/html;charset=UTF-8' />")
		p("<style type='text/css' media='screen'>")
		p("hr { color: blue; background-color: blue; height: 5px; margin: 0; padding: 0; border: 0px;")
		p("		-webkit-margin-before: 0px; -webkit-margin-after: 0px; }")
		p("div.metric div { width:100%; height:100%; overflow: hidden; }")
		p("div.status_ok div { background-color:lightgreen; }")
		p("div.status_fail div { background-color:#c00000; color: #ffffff;}")
		p("div.metric { }")
		p("div.metric:hover { }")
		p("div.metric span { visibility: hidden; position: absolute; left: 2em; margin-top: 1em; padding: 1em; }")
		p("div.metric:hover span { visibility: visible; border: 1px solid #347BEE; ")
		p("		color: #000000; background: #FFFFFF; z-index: 5;}")
		p("</style></head><body>")
	end

	def do_write_data
		@height += SPACE_BETWEEN_LINES if @fwl > 0

		@data.each {|d|
			case d[0]
			when :title
				x, y, w, h = transform_xywh(0, 0, @fwl, d[1][:height])[0]
				s = ["position:absolute", "left:#{x}px", "top:#{y}px", "width:#{w}px", "height:#{h}px"]
				ss = ["margin: 0", "text-align: center", "line-height: #{d[1][:height]}px", \
						"font-size: #{d[1][:height] * 0.75}px", "white-space: nowrap"]
				p("<div style='#{s.join("; ")}'><h1 style='#{ss.join("; ")}'>#{d[2]}</h1></div>")
				@h_offset += d[1][:height]
			when :text
				transform_xywh(d[1][:x], d[1][:y], d[1][:width], d[1][:height]).each {|x, y, w, h|
					s = ["position:absolute", "left:#{x}px", "top:#{y}px", "width:#{w}px", "height:#{h}px", \
							"white-space: nowrap"]
					d[1].each {|k,v| s << "#{k}:#{v}" if k.class == String} 
					p("<div style='#{s.join("; ")}'>#{d[2]}</div>")
				}
			when :rect
				transform_xywh(d[1][:x], d[1][:y], d[1][:width], d[1][:height]).each {|x, y, w, h|
					s = ["position:absolute", "left:#{x}px", "top:#{y}px", "width:#{w}px", "height:#{h}px", \
							"background-color:#{d[1][:fill]}", \
							"border:#{d[1]["stroke-width"]} solid #{d[1][:stroke]}", \
							"white-space: nowrap"]
					p("<div style='#{s.join("; ")}'></div>")
				}
			when :div
				transform_xywh(d[1][:x], d[1][:y], d[1][:width], d[1][:height]).each {|x, y, w, h|
					s = ["position:absolute", "left:#{x}px", "top:#{y}px", "width:#{w}px", "height:#{h}px", \
							"background-color:#{d[1][:fill]}", \
							"border:#{d[1]["stroke-width"]} solid #{d[1][:stroke]}", \
							"white-space: nowrap"]

					c= ["metric"]
					d[1].each {|k,v| next if k.class != String
						(c << v.downcase; next) if k == "class"
						s << "#{k}:#{v}"
					} 

					p("<div class='#{c.join(" ")}' style='#{s.join("; ")}'>")
					p("<div>#{d[2].gsub("\n", "<br />")}</div>") if d[2].to_s != ""
					p("<span>#{d[3]}</span>") if d[3].to_s != ""
					p("</div>")
				}
			else
				$stderr.puts "skipped #{d}"
			end
		}

		i = 0; (1..((@width / @fwl) + 1)).to_a.each {|j| i = j
			p("<hr style='position:absolute; left:0px; " + \
					"top:#{(@h_offset + @height * i) - (SPACE_BETWEEN_LINES / 2)}px; width:#{@fwl}px' />")
		}
		p("<hr style='position:absolute; left:0px; " + \
				"top:#{(@h_offset + @height * i) - (SPACE_BETWEEN_LINES / 6)}px; width:#{@fwl}px' />")

		@h_offset += (@height * (@width / @fwl.to_f).ceil)
		@height -= SPACE_BETWEEN_LINES if @fwl > 0
	end

	def do_write_close
		p("</body></html>")
	end
end

#methods

@available_format = ["html"]
@params = {:format => @available_format.first, :details => false}
def usage(msg= "")
	$stderr.puts "usage: #{$0} [options] <ifname> <ofname>"
	$stderr.puts "\t-h, --help		shows this message"
#	$stderr.puts "\t-f, --format [type]	select output format [available #{@available_format.join(", ")}]"
	$stderr.puts "\t-d, --details		display every process on one line"
	$stderr.puts "\t-l, --limit [size]	limits the pagewidth [! makes only sense when details are off]"
#	$stderr.puts "\tDefault Format: #{@params[:format]}"
	$stderr.puts msg if msg.to_s != ""
	exit(msg.to_s != "")
end

def pars_parameter
	opts = GetoptLong.new(
		[ "--help", "-h", GetoptLong::NO_ARGUMENT ],
		[ "--format", "-f", GetoptLong::REQUIRED_ARGUMENT ],
		[ "--details", "-d", GetoptLong::NO_ARGUMENT ],
		[ "--limit", "-l", GetoptLong::REQUIRED_ARGUMENT ],
	)

	begin
		opts.each do |opt, arg|
			case opt
				when "--help"	then usage
				when "--format"
					usage("unknown format #{arg}") if not @available_format.include?(arg)
					@params[:format] = arg.to_s
				when "--details"then @params[:details] = true
				when "--limit"	then @params[:pagewidth_limit] = arg.to_i
			end
		end
	rescue => err
		usage("#{err.class()}: #{err.message}")
	end

	usage("Too many parameters") if ARGV.size > 2

	@params[:finame] = ((ARGV.size < 1) ? "-" : ARGV[0])
	@params[:foname] = ((ARGV.size < 2) ? "-" : ARGV[1])
end

def select_former(format)
	case format
		when "html"	then return HTML.new
		else raise "unknown format '#{format}'"
	end
end


@builds = []
def load_metrics(fname)
	fin = ((fname == "-") ? $stdin : File.new(fname, "r"))
	fin_data = fin.readlines
	fin_data = "<root>#{fin_data.join("")}</root>"
	fin.close() if fname != "-"

	doc = REXML::Document.new(fin_data)

	doc.elements.each("*/build") { |tasks| tas = tasks.attributes
		m= {:all => [], :mvls => {:min => nil, :max => nil, :smdiff => nil, :resources => []}, :desc => {}}

		m[:desc][:project] = tas['project']
		m[:desc][:started_t] = Time.at((m[:desc][:started] = tas['started'].to_f))
		m[:desc][:ended_t] = Time.at((m[:desc][:ended] = tas['finished'].to_f))
		m[:desc][:duration] = tas['duration'].to_f

		tasks.elements.each("task") { |task| ta= task.attributes
			o = {}
			o[:pn] = ta['pn']
			o[:name] = ta['name']
			o[:version] = "#{ta['pv']} #{ta['pr']}"
			o[:status] = ta['result']

			o[:started_t] = Time.at((o[:started] = ta['started'].to_f))
			o[:ended_t] = Time.at((o[:ended] = ta['ended'].to_f))
			o[:duration] = ta['duration'].to_f
			
			o[:usage] = {}

			task.elements.each() {|t_sk| next if t_sk.name != "resource"
				t_ = t_sk.attributes
				o[:usage][t_['who'].to_sym] = {} if o[:usage][t_['who'].to_sym].nil?
				o[:usage][t_['who'].to_sym][t_['id'].to_sym] = t_sk.text
				m[:mvls][:resources] << t_['id'].to_sym if not m[:mvls][:resources].include?(t_['id'].to_sym)
			}

			m[ta['pn']]= m[ta['pn']].to_a
			m[ta['pn']] << o
			m[:all] << o

			m[:mvls][:min] = o[:started] if m[:mvls][:min].nil? or m[:mvls][:min] > o[:started]
			m[:mvls][:max] = o[:ended]   if m[:mvls][:max].nil? or m[:mvls][:max] < o[:ended]

			diff= o[:ended] - o[:started]
			m[:mvls][:smdiff]= diff if m[:mvls][:smdiff].nil? or (m[:mvls][:smdiff] > diff and diff != 0.0)
		}
		m[:mvls][:factor] = @design[:min_width] / m[:mvls][:smdiff]
		@builds << m
	}
end

def h_timefmt(time)
	return "#{time.strftime("%d.%m.%Y %H:%M:%S")}.#{sprintf("%02i", (time.usec / 10000.0).ceil)}"
end

def gen_details(task, mvls)
	raise "Only support 'html' from get_details" if @params[:format] != "html"

	details= ""
	details += "<object><table>"
	{"Name" => :pn, "Task" => :name, "Version" => :version, "Status" => :status}.each {|k, v|
		details += "<tr><td><b>#{k}:</b></td><td style='white-space: nowrap'>#{task[v]}</td></tr>"
	}

	{"Started" => :started_t, "Ended" => :ended_t}.each {|k, v|
		details += "<tr><td><b>#{k}:</b></td><td style='white-space: nowrap'>#{h_timefmt(task[v])}</td></tr>"
	}
	details += "<tr><td><b>Duration:</b></td>" + \
			"<td style='white-space: nowrap'>#{sprintf("%.4f", task[:duration].to_f)}s</td></tr>"
	details += "</table></object><br /><br />"

	details += "<object><table>"
	{:Usage => nil, "Children" => task[:usage][:children], "Self" => task[:usage][:self]}.each {|l, v|
		details += "<tr><td><b>#{l}:</b></td>"
		mvls[:resources].each {|r|
			details += "<td>#{(v.nil?) ? "<b>#{r.to_s}</b>" : v[r]}</td>"
		}
		details += "</tr>"
	}
	details += "</table></object>"

	return details
end

def display_proc(former, tasks, mvls, y, inc_parent= false)
	register = [0]
	ipf = (inc_parent ? 2 : 1)

	tasks.each {|task|
		ureg= register.size 
		register.each_with_index {|reg, i|
			(ureg= i; break) if reg < task[:started]
		}

		tx = (@params[:details] ? @design[:tx_offset] : 0) + ((task[:started] - mvls[:min]) * mvls[:factor])
		ty = y + (ureg * ipf * (@design[:y_height] + @design[:y_margin]))
		wth = (task[:ended] - task[:started]) * mvls[:factor]
		height= @design[:y_height] * ipf

		former.textbox(tx, ty, wth, height, @design[:t_fontsize], "#{task[:pn]}\n#{task[:name]}", \
				gen_details(task, mvls), {"class" => "status_#{task[:status]}"})

		register[ureg] = task[:ended]
	}

	return register.size * ipf
end

#main
pars_parameter
former = select_former(@params[:format])
load_metrics(@params[:finame])

if not @params[:details]
	former.write_open(@params[:foname], @params[:pagewidth_limit])
	former.do_write_head
	@builds.each {|metrics|
		d= metrics[:desc]
		former.title(d[:project])
		former.stitle("Started: #{h_timefmt(d[:started_t])} Finished: #{h_timefmt(d[:ended_t])}")

		sort = metrics[:all].sort{|a,b| a[:started] <=> b[:started]}
		display_proc(former, sort, metrics[:mvls], 0, true)

		former.do_write_data
		former.clear
	}
	former.do_write_close
	former.write_close
else
	raise "TODO"

	i = 0
	@metrics.each {|name, tasks|
		y = (i + 1) * (@design[:y_height] + @design[:y_margin])

		(i += 3; name="ALLE") if name == :all
		former.btext(2, y, @design[:tx_offset], @design[:fontsize], @design[:fontsize], name)
		sort = tasks.sort{|a,b| a[:started] <=> b[:started]}
		i += display_proc(former, sort, y, (name == "ALLE"))
	}
end
