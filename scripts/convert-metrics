#!/usr/bin/env ruby

require "getoptlong"
require "rexml/document"

# defs
def defs
	bfs= 10; bfs_crop= 0.8
	@design = {:y_height => bfs, :y_margin => 2, :fontsize => "#{bfs}px", :t_fontsize => "#{bfs * bfs_crop}px", \
			:min_width => 1, :tx_offset => 100}
	@design[:t_boxpadding] = @design[:y_height] - (bfs * bfs_crop)
end
@design = {}; defs

class HTML
	SPACE_BETWEEN_LINES = 30

	def initialize
		clear
		clear_offset
		clear_datacache
		set_drawvertical(false)
		set_lineheight(0)
		set_fontsize(0)
	end

	def clear;		@data = [];	@width = 0;	@height = 0;	end
	def clear_offset;	@h_offset = 0;	@w_offset = 0;			end
	def clear_datacache;	@datacache = [];				end

	def set_drawvertical(b);@drawvertical = !!b;	end
	def set_lineheight(i);	@lineheight = i.to_i;	end
	def set_fontsize(i);	@fontsize = i.to_i;	end

	def a(*d)
		if @drawvertical
			c_width= d[1][:x].to_f + @lineheight.to_f
			c_height= d[1][:y].to_f + d[1][:width].to_f
		else
			c_width= d[1][:x].to_f + d[1][:width].to_f
			c_height= d[1][:y].to_f + @lineheight.to_f
		end
		@width= c_width.ceil if @width < c_width.to_f
		@height= c_height.ceil if @height < c_height.to_f

		@data << d
	end

	def title(text, o={}); a(:title, o.merge({:height => SPACE_BETWEEN_LINES * 2}), text); end
	def stitle(text, o={});a(:title, o.merge({:height => SPACE_BETWEEN_LINES / 2}), text); end

	def textbox(x, y, w, text=nil, text2=nil, o={})
		a(:div, o.merge({:x => (@drawvertical ? y : x), :y => (@drawvertical ? x : y), :width => w}), text, text2)
	end

	def saveDataCache
		@datacache << {:data => @data, :width => @width, :height => @height} if @data.size > 0
		clear
	end

	def p(txt); @f.puts txt; end
	def write_singlefile(fname, pagewidth_limit = 0, datacache = @datacache)
		saveDataCache

		write_open(fname, pagewidth_limit)

		dc= nil; dc_v= 0
		datacache.each {|datac| v= datac[(@drawvertical ? :height : :width)]; (dc_v = v; dc = datac) if dc_v < v }
		dc[:data].each {|d| next if d[0] != :title; dc_v += d[1][:height]} if (not dc.nil?) and @drawvertical

		do_write_head(dc_v.nil? ? nil : "#{((@fwl == 0) ? dc_v : @fwl)}px" )
		datacache.each {|datac| do_write_data(datac[:data], datac[:width], datac[:height]) }
		do_write_close
		write_close
	end

	def write_dir(fname, pagewidth_limit = 0)
		saveDataCache

		dir= fname + ".d/"
		dir_base= File.basename(fname) + ".d/"
		Dir.mkdir(dir) if not Dir.exist?(dir)

		index= []
		@datacache.each_with_index {|datac, i|
			clear_offset
			name = []
			datac[:data].each {|d| next if d[0] != :title; name << d[2] }
			name = name.join(" - ")

			index << ["#{dir_base}#{i}.html", name]
			write_singlefile("#{dir}#{i}.html", pagewidth_limit, [datac])
		}

		write_open(fname)
		do_write_head
		p("<h1>Index</h1>")
		index.each {|i| p("<a href='#{i[0]}'>#{i[1]}</a><br/>")}
		do_write_close
		write_close
	end

private
	def write_open(fname, pagewidth_limit = 0)
		@fwl= pagewidth_limit.to_i
		@f = ((fname == "-") ? $stdout : File.new(fname, "w"))
	end

	def write_close
		@f.close() if @f != "-"
		@f = nil
	end

	def transform_xyw(x, y, w, h)
		return [[(x.to_i + @w_offset), (y.to_i + @h_offset), w.to_i]] if @fwl == 0

		pos= []
		((x/@fwl).floor..((x+w)/@fwl).floor).to_a.each {|i|
			_x = x % @fwl; x = 0
			_w = (((_x + w) > @fwl) ? @fwl - _x : w); w -= _w
			next if _w == 0
			pos << [(_x.to_i + @w_offset), (y.to_i + (i * h) + @h_offset), _w.to_i]
		}

		return pos
	end

	def do_write_head(calced_hrsize= "100%")
		p("<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'")
		p("\t'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>")
		p("<html xmlns='http://www.w3.org/1999/xhtml'>")
		p("<head><title>Generated by convert-mertrics</title>")
		p("<meta http-equiv='Content-Type' content='text/html;charset=UTF-8' />")
		p("<style type='text/css' media='screen'>")
		p("hr { position:absolute; color: blue; background-color: blue;")
		if @drawvertical; then p("		top:0px; width: 5px; height: #{calced_hrsize};")
				  else p("		left:0px; height: 5px; width: #{calced_hrsize};"); end
		p("		margin: 0; padding: 0; border: 0px; -webkit-margin-before: 0px; -webkit-margin-after: 0px; }")
		p("h1 { margin: 0; text-align: center; white-space: nowrap; }")
		raise "lineheight is missing" if @lineheight.to_i == 0
		raise "fontsize is missing" if @fontsize.to_i == 0
		p("div { position:absolute; white-space: nowrap; font-family: Arial; font-size:#{@fontsize}px; ")
		p("		#{@drawvertical ? "width" : "height"}: #{@lineheight}px; }")
		p("div.metric div { width:100%; height:100%; overflow: hidden; background-color: white; border:black solid 1px;}")
		p("div.status_ok div { background-color:lightgreen; }")
		p("div.status_fail div { background-color:#c00000; color: #ffffff;}")
		p("div.metric { }")
		p("div.metric:hover { }")
		p("div.metric span.a { visibility: hidden; position: fixed; margin-top: 1em; padding: 1em; bottom: 10px; right: 10px; }")
		p("div.metric:hover span.a { visibility: visible; border: 1px solid #347BEE;")
		p("		color: #000000; background: #FFFFFF; z-index: 5;}")
		if @drawvertical
			{"t" => [90], "s" => [270, "bottom: 1px;"]}.each {|k, v|
				s= ""; ["", "-ms-", "-webkit-"].each {|l| l+="transform";
					s += "#{l}: rotate(#{v[0]}deg); #{l}-origin: #{@lineheight/2}px 50%; "
				}
				p("div.metric span.#{k} {position: absolute; #{v[1]}#{s} }")
			}
		end
		p("td { white-space: nowrap; font-family: Arial; }")
		p("th { white-space: nowrap; text-align: left; font-family: Arial; }")
		p("</style></head><body>")
	end

	def do_write_data(data, width, height)
		height += SPACE_BETWEEN_LINES
		width  += SPACE_BETWEEN_LINES

		data.each {|d|
			case d[0]
			when :title
				x, y, w = transform_xyw(0, 0, @fwl, height)[0]
				s = ["left:#{x}px", "top:#{y}px", "width:#{w}px", "height:#{d[1][:height]}px"]
				ss = ["line-height: #{d[1][:height]}px", "font-size: #{(d[1][:height] * 0.75).to_i}px"]
				p("<div style='#{s.join("; ")}'><h1 style='#{ss.join("; ")}'>#{d[2]}</h1></div>")
				@h_offset += d[1][:height]

				# Not scientific, but it works for now
				if @drawvertical
					c_width = ((d[2].size * d[1][:height]) / 2.8).to_i + SPACE_BETWEEN_LINES
					width = c_width if width < c_width
				end
			when :div
				transform_xyw(d[1][:x], d[1][:y], d[1][:width], height).each {|x, y, w|
					s = ["left:#{x}px", "top:#{y}px", "#{@drawvertical ? "height" : "width"}:#{w}px"]

					c= ["metric"]
					d[1].each {|k,v| (c << v.downcase; next) if k.class == String and k == "class"
						s << "#{k}:#{v}"
					} 

					p("<div class='#{c.join(" ")}' style='#{s.join("; ")}'>")
					p("<div><span class='s'>#{d[2].gsub("\n", "<br/>")}</span></div>") if d[2].to_s != ""
					p("<span class='a'>#{d[3]}</span>") if d[3].to_s != ""
					p("</div>")
				}
			else
				$stderr.puts "skipped #{d}"
			end
		}
		if @drawvertical
			p("<hr style='left:#{(@w_offset + width) - (SPACE_BETWEEN_LINES / 3 * 2)}px;' />")
			p("<hr style='left:#{(@w_offset + width) - (SPACE_BETWEEN_LINES / 3)}px;' />")

			@h_offset = 0
			@w_offset += width
		else
			i = 0; (1..(((@fwl != 0 ) ? (width / @fwl) : 0) + 1)).to_a.each {|j| i = j
				p("<hr style='top:#{(@h_offset + height * i) - (SPACE_BETWEEN_LINES / 2)}px;' />")
			}
			p("<hr style='top:#{(@h_offset + height * i) - (SPACE_BETWEEN_LINES / 6)}px;' />")

			@h_offset += (height * ((@fwl != 0 ) ? (width / @fwl.to_f).ceil : 1))
		end
	end

	def do_write_close; 
		p("</body></html>")
	end
end

#methods

@available_format = ["html"]
@params = {:format => @available_format.first, :vertical => true, :singlefile => false}
def usage(msg= "")
	$stderr.puts "usage: #{$0} [options] <ifname> <ofname>"
	$stderr.puts "\t-h, --help		shows this message"
	$stderr.puts "\t-l, --limit [size]	limits the pagewidth"
	$stderr.puts "\t-v, --horizontal	aligns the metrics horizontal"
	$stderr.puts "\t-s, --singlefile	outputs one htmlfile"
#	$stderr.puts "\t-f, --format [type]	select output format [available #{@available_format.join(", ")}]"
#	$stderr.puts "\tDefault Format: #{@params[:format]}"
	$stderr.puts msg if msg.to_s != ""
	exit(msg.to_s != "")
end

def pars_parameter
	opts = GetoptLong.new(
		[ "--help",		"-h", GetoptLong::NO_ARGUMENT ],
		[ "--limit",		"-l", GetoptLong::REQUIRED_ARGUMENT ],
		[ "--horizontal"	"-z", GetoptLong::NO_ARGUMENT ],
		[ "--singlefile",	"-s", GetoptLong::NO_ARGUMENT ],
		[ "--format",		"-f", GetoptLong::REQUIRED_ARGUMENT ],
	)

	begin
		opts.each do |opt, arg|
			case opt
				when "--help"		then usage
				when "--limit"		then @params[:pagewidth_limit] = arg.to_i
				when "--horizontal"	then @params[:vertical] = false
				when "--singlefile"	then @params[:singlefile] = true
				when "--format"
					usage("unknown format #{arg}") if not @available_format.include?(arg)
					@params[:format] = arg.to_s
			end
		end
	rescue => err
		usage("#{err.class()}: #{err.message}")
	end

	usage("--limit can't be used together when drawing vertical (use --horizontal)") \
			if @params[:vertical] and @params[:pagewidth_limit].to_i != 0

	usage("Too many parameters") if ARGV.size > 2
	@params[:finame] = ((ARGV.size < 1) ? "-" : ARGV[0])
	@params[:foname] = ((ARGV.size < 2) ? "-" : ARGV[1])

	usage("stdout can't be used for multifile-mode") if @params[:foname] == "-" and not @params[:singlefile]
end

def select_former(format)
	case format
		when "html"	then return HTML.new
		else raise "unknown format '#{format}'"
	end
end


@builds = []
@mvls = {:biggest_timelaps => 0}
def load_metrics(fname)
	fin = ((fname == "-") ? $stdin : File.new(fname, "r"))
	fin_data = fin.readlines
	fin_data = "<root>#{fin_data.join("")}</root>"
	fin.close() if fname != "-"

	doc = REXML::Document.new(fin_data)

	doc.elements.each("*/build") { |tasks| tas = tasks.attributes
		m= {:all => [], :mvls => {:min => nil, :max => nil, :smdiff => nil, :resources => []}, :desc => {}}

		m[:desc][:project] = tas['project']
		m[:desc][:started_t] = Time.at((m[:desc][:started] = tas['started'].to_f))
		m[:desc][:ended_t] = Time.at((m[:desc][:ended] = tas['finished'].to_f))
		m[:desc][:duration] = tas['duration'].to_f
		t = (m[:desc][:ended_t] - m[:desc][:started_t])
		@mvls[:biggest_timelaps] = t if @mvls[:biggest_timelaps].to_f < t

		tasks.elements.each("task") { |task| ta= task.attributes
			o = {}
			o[:pn] = ta['pn']
			o[:name] = ta['name']
			o[:version] = "#{ta['pv']} #{ta['pr']}"
			o[:status] = ta['result']

			o[:started_t] = Time.at((o[:started] = ta['started'].to_f))
			o[:ended_t] = Time.at((o[:ended] = ta['ended'].to_f))
			o[:duration] = ta['duration'].to_f
			
			o[:usage] = {}

			task.elements.each() {|t_sk| next if t_sk.name != "resource"
				t_ = t_sk.attributes
				o[:usage][t_['who'].to_sym] = {} if o[:usage][t_['who'].to_sym].nil?
				o[:usage][t_['who'].to_sym][t_['id'].to_sym] = t_sk.text
				m[:mvls][:resources] << t_['id'].to_sym if not m[:mvls][:resources].include?(t_['id'].to_sym)
			}

			m[:all] << o

			m[:mvls][:min] = o[:started] if m[:mvls][:min].nil? or m[:mvls][:min] > o[:started]
			m[:mvls][:max] = o[:ended]   if m[:mvls][:max].nil? or m[:mvls][:max] < o[:ended]

			diff= o[:ended] - o[:started]
			m[:mvls][:smdiff]= diff if m[:mvls][:smdiff].nil? or (m[:mvls][:smdiff] > diff and diff != 0.0)
		}
		m[:mvls][:factor] = @design[:min_width] / m[:mvls][:smdiff]
		@mvls[:factor] = m[:mvls][:factor] if @mvls[:factor].to_f < m[:mvls][:factor]
		@builds << m
	}
end

def h_timefmt(time)
	return "#{time.strftime("%d.%m.%Y %H:%M:%S")}.#{sprintf("%02i", (time.usec / 10000.0).ceil)}"
end

def gen_details(task, mvls)
	raise "Only support 'html' from get_details" if @params[:format] != "html"

	details= ""
	details += "<object><table>"
	{"Name" => :pn, "Task" => :name, "Version" => :version, "Status" => :status}.each {|k, v|
		details += "<tr><th>#{k}:</th><td>#{task[v]}</td></tr>"
	}

	{"Started" => :started_t, "Ended" => :ended_t}.each {|k, v|
		details += "<tr><th>#{k}:</td><td>#{h_timefmt(task[v])}</td></tr>"
	}
	details += "<tr><th>Duration:</td><td>#{sprintf("%.4f", task[:duration].to_f)}s</td></tr>"
	details += "</table></object><br/>"

	details += "<object><table>"
	r_s= (mvls[:resources].size / 2).ceil
	[mvls[:resources][0...r_s], mvls[:resources][r_s..-1]].each {|res|
		{:Usage => nil, "Children" => task[:usage][:children], "Self" => task[:usage][:self]}.each {|l, v|
			details += "<tr><th>#{l}:</td>"
			res.each {|r|
				details += ((v.nil?) ? "<th>#{r.to_s}</th>" : "<td>#{v[r]}</td>")
			}
			details += "</tr>"
		}
	}
	details += "</table></object>"

	return details
end

def display_proc(former, tasks, mvls, y, inc_parent= false)
	register = [0]
	ipf = (inc_parent ? 2 : 1)

	tasks.each {|task|
		ureg= register.size 
		register.each_with_index {|reg, i|
			(ureg= i; break) if reg < task[:started]
		}

		tx = (@params[:details] ? @design[:tx_offset] : 0) + ((task[:started] - mvls[:min]) * @mvls[:factor])
		ty = y + (ureg * ipf * (@design[:y_height] + @design[:y_margin]))
		wth = (task[:ended] - task[:started]) * @mvls[:factor]

		former.textbox(tx, ty, wth, "#{task[:pn]}\n#{task[:name]}", \
				gen_details(task, mvls), {"class" => "status_#{task[:status]}"})

		register[ureg] = task[:ended]
	}

	return register.size * ipf
end

#main
pars_parameter
former = select_former(@params[:format])
load_metrics(@params[:finame])

former.set_drawvertical(@params[:vertical])
former.set_lineheight(@design[:y_height] * 2)
former.set_fontsize(@design[:t_fontsize])

@builds.each {|metrics|
	d= metrics[:desc]
	former.title(d[:project])
	former.stitle("Started: #{h_timefmt(d[:started_t])}")
	former.stitle("Finished: #{h_timefmt(d[:ended_t])}")

	sort = metrics[:all].sort{|a,b| a[:started] <=> b[:started]}
	display_proc(former, sort, metrics[:mvls], 0, true)

	former.saveDataCache
}

if @params[:singlefile]
	former.write_singlefile(@params[:foname], @params[:pagewidth_limit])
else
	former.write_dir(@params[:foname], @params[:pagewidth_limit])
end
