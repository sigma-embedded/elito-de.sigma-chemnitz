From 7565efcb75f444d8487ddfb6040908f8efb4c2be Mon Sep 17 00:00:00 2001
From: Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
Date: Sat, 26 Jul 2014 17:51:28 +0200
Subject: [PATCH] added is_selinux_enabled() wrapper

'pseudo' supports only the xattr part of the SELinux API but there are
other ways like writing into /proc/self/attr/ files which might affect
results or break operation.

For example, in an "install src dst && sed -i -e '' dst" sequence,

1. 'install' calculates the file context of 'dst' by using the
   global SELinux policy

2. 'install' calls the 'pseudo' wrapped setxattr()

3. 'sed' uses the /proc API which speaks to the kernel directly and
   can make the following operations fail

As item 1 uses the host wide policy (which might differ from a
potential target policy), it does not make much sense at all to set
SELinux contexts during a normal build process.  Patch disables
SELinux support by default hence and requires an explicit
PSEUDO_ALLOW_SELINUX=1 to enable it e.g. when fixing contexts of an
image.

Signed-off-by: Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
---
 ports/linux/guts/is_selinux_enabled.c     | 16 ++++++++++++++++
 ports/linux/guts/is_selinux_mls_enabled.c | 17 +++++++++++++++++
 ports/linux/wrapfuncs.in                  |  3 +++
 pseudo.1                                  |  7 +++++++
 pseudo.h                                  |  1 +
 pseudo_client.c                           | 17 +++++++++++++++++
 pseudo_util.c                             |  1 +
 7 files changed, 62 insertions(+)
 create mode 100644 ports/linux/guts/is_selinux_enabled.c
 create mode 100644 ports/linux/guts/is_selinux_mls_enabled.c

Index: pseudo-1.8.1/ports/linux/guts/is_selinux_enabled.c
===================================================================
--- /dev/null
+++ pseudo-1.8.1/ports/linux/guts/is_selinux_enabled.c
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) 2014 Wind River Systems; see
+ * guts/COPYRIGHT for information.
+ *
+ * int is_selinux_enabled(void)
+ *	int rc = -1;
+ */
+
+	if (!pseudo_allow_selinux)
+		rc = 0;
+	else
+		rc = real_is_selinux_enabled();
+
+/*	return rc;
+ * }
+ */
Index: pseudo-1.8.1/ports/linux/guts/is_selinux_mls_enabled.c
===================================================================
--- /dev/null
+++ pseudo-1.8.1/ports/linux/guts/is_selinux_mls_enabled.c
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2014 Wind River Systems; see
+ * guts/COPYRIGHT for information.
+ *
+ * int is_selinux_mls_enabled(void)
+ *	int rc = -1;
+ */
+
+	if (!pseudo_allow_selinux)
+		rc = 0;
+	else
+		rc = real_is_selinux_mls_enabled();
+
+
+/*	return rc;
+ * }
+ */
Index: pseudo-1.8.1/ports/linux/wrapfuncs.in
===================================================================
--- pseudo-1.8.1.orig/ports/linux/wrapfuncs.in
+++ pseudo-1.8.1/ports/linux/wrapfuncs.in
@@ -53,3 +53,6 @@ int euidaccess(const char *path, int mod
 int getpw(uid_t uid, char *buf);
 int getpwent_r(struct passwd *pwbuf, char *buf, size_t buflen, struct passwd **pwbufp);
 int getgrent_r(struct group *gbuf, char *buf, size_t buflen, struct group **gbufp);
+
+int is_selinux_enabled(void);
+int is_selinux_mls_enabled(void);
Index: pseudo-1.8.1/pseudo.1
===================================================================
--- pseudo-1.8.1.orig/pseudo.1
+++ pseudo-1.8.1/pseudo.1
@@ -485,6 +485,13 @@ discarded silently, even when
 .B PSEUDO_DISABLED
 is set. The value specified doesn't matter.
 .TP 8
+.B PSEUDO_ALLOW_SELINUX
+If this variable is not set, pseudo returns always false for
+.IR is_selinux_enabled(3) .
+Programs like \fIinstall\fR or \fIsed\ \-i\fR will not try to set
+filecontexts which might fail and causing nasty sideeffects when
+running as a confined user.
+.TP 8
 .B PSEUDO_ENOSYS_ABORT
 If this variable is set, the
 .I pseudo
Index: pseudo-1.8.1/pseudo.h
===================================================================
--- pseudo-1.8.1.orig/pseudo.h
+++ pseudo-1.8.1/pseudo.h
@@ -42,6 +42,7 @@ extern unsigned long pseudo_util_evlog_f
 extern int pseudo_util_debug_fd;
 extern int pseudo_disabled;
 extern int pseudo_allow_fsync;
+extern int pseudo_allow_selinux;
 extern int pseudo_diag(char *, ...) __attribute__ ((format (printf, 1, 2)));
 extern int pseudo_evlog_internal(char *, ...) __attribute__ ((format (printf, 1, 2)));
 #define pseudo_evlog(x, ...) do { \
Index: pseudo-1.8.1/pseudo_client.c
===================================================================
--- pseudo-1.8.1.orig/pseudo_client.c
+++ pseudo-1.8.1/pseudo_client.c
@@ -74,6 +74,7 @@ char *pseudo_cwd_rel = NULL;
 /* used for PSEUDO_DISABLED */
 int pseudo_disabled = 0;
 int pseudo_allow_fsync = 0;
+int pseudo_allow_selinux = 0;
 static int pseudo_local_only = 0;
 static int pseudo_client_logging = 1;
 
@@ -514,6 +515,22 @@ pseudo_init_client(void) {
 		pseudo_allow_fsync = 0;
 	}
 
+	/* ALLOW_SELINUX is here because 'pseudo' does not emulate complete
+	 * SELinux yet.  Returning false on 'is_selinux_enabled()' makes
+	 * programs like 'install' or 'sed' behave more nicely
+	 */
+	env = getenv("PSEUDO_ALLOW_SELINUX");
+	if (!env) {
+		env = pseudo_get_value("PSEUDO_ALLOW_SELINUX");
+	} else {
+		pseudo_set_value("PSEUDO_ALLOW_SELINUX", env);
+	}
+	if (env) {
+		pseudo_allow_selinux = 1;
+	} else {
+		pseudo_allow_selinux = 0;
+	}
+
 	/* in child processes, PSEUDO_UNLOAD may become set to
 	 * some truthy value, in which case we're being asked to
 	 * remove pseudo from the LD_PRELOAD. We need to make sure
Index: pseudo-1.8.1/pseudo_util.c
===================================================================
--- pseudo-1.8.1.orig/pseudo_util.c
+++ pseudo-1.8.1/pseudo_util.c
@@ -67,6 +67,7 @@ static struct pseudo_variables pseudo_en
 	{ "PSEUDO_DISABLED", 15, NULL },
 	{ "PSEUDO_UNLOAD", 13, NULL },
 	{ "PSEUDO_ALLOW_FSYNC", 18, NULL },
+	{ "PSEUDO_ALLOW_SELINUX", 20, NULL },
 #ifdef PSEUDO_PROFILING
 	{ "PSEUDO_PROFILE_PATH", 19, NULL },
 #endif
