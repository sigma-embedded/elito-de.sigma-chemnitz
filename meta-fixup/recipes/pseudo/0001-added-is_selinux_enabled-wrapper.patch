From 8adba7fe420bc64d5947b6878e2153bebc4495fb Mon Sep 17 00:00:00 2001
From: Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
Date: Sat, 26 Jul 2014 17:51:28 +0200
Subject: [PATCH] added is_selinux_enabled() wrapper

'pseudo' supports only the xattr part of the SELinux API but there are
other ways like writing into /proc/self/attr/ files which might affect
results or break operation.

For example, in an "install src dst && sed -i -e '' dst" sequence,

1. 'install' calculates the file context of 'dst' by using the
   global SELinux policy

2. 'install' calls the 'pseudo' wrapped setxattr()

3. 'sed' uses the /proc API which speaks to the kernel directly and
   can make the following operations fail

As item 1 uses the host wide policy (which might differ from a
potential target policy), it does not make much sense at all to set
SELinux contexts during a normal build process.  Patch disables
SELinux support by default hence and requires an explicit
PSEUDO_ALLOW_SELINUX=1 to enable it e.g. when fixing contexts of an
image.

Signed-off-by: Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
---
 ports/linux/guts/is_selinux_enabled.c     | 16 ++++++++++++++++
 ports/linux/guts/is_selinux_mls_enabled.c | 17 +++++++++++++++++
 ports/linux/wrapfuncs.in                  |  3 +++
 pseudo.1                                  |  7 +++++++
 pseudo.h                                  |  1 +
 pseudo_client.c                           | 17 +++++++++++++++++
 pseudo_util.c                             |  1 +
 7 files changed, 62 insertions(+)
 create mode 100644 ports/linux/guts/is_selinux_enabled.c
 create mode 100644 ports/linux/guts/is_selinux_mls_enabled.c

diff --git a/ports/linux/guts/is_selinux_enabled.c b/ports/linux/guts/is_selinux_enabled.c
new file mode 100644
index 0000000..18c3144
--- /dev/null
+++ b/ports/linux/guts/is_selinux_enabled.c
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) 2014 Wind River Systems; see
+ * guts/COPYRIGHT for information.
+ *
+ * int is_selinux_enabled(void)
+ *	int rc = -1;
+ */
+
+	if (!pseudo_allow_selinux)
+		rc = 0;
+	else
+		rc = real_is_selinux_enabled();
+
+/*	return rc;
+ * }
+ */
diff --git a/ports/linux/guts/is_selinux_mls_enabled.c b/ports/linux/guts/is_selinux_mls_enabled.c
new file mode 100644
index 0000000..e022bd2
--- /dev/null
+++ b/ports/linux/guts/is_selinux_mls_enabled.c
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2014 Wind River Systems; see
+ * guts/COPYRIGHT for information.
+ *
+ * int is_selinux_mls_enabled(void)
+ *	int rc = -1;
+ */
+
+	if (!pseudo_allow_selinux)
+		rc = 0;
+	else
+		rc = real_is_selinux_mls_enabled();
+
+
+/*	return rc;
+ * }
+ */
diff --git a/ports/linux/wrapfuncs.in b/ports/linux/wrapfuncs.in
index 3b8955a..07e6482 100644
--- a/ports/linux/wrapfuncs.in
+++ b/ports/linux/wrapfuncs.in
@@ -51,3 +51,6 @@ int euidaccess(const char *path, int mode);
 int getpw(uid_t uid, char *buf);
 int getpwent_r(struct passwd *pwbuf, char *buf, size_t buflen, struct passwd **pwbufp);
 int getgrent_r(struct group *gbuf, char *buf, size_t buflen, struct group **gbufp);
+
+int is_selinux_enabled(void);
+int is_selinux_mls_enabled(void);
diff --git a/pseudo.1 b/pseudo.1
index 6906345..ab27ac4 100644
--- a/pseudo.1
+++ b/pseudo.1
@@ -485,6 +485,13 @@ discarded silently, even when
 .B PSEUDO_DISABLED
 is set. The value specified doesn't matter.
 .TP 8
+.B PSEUDO_ALLOW_SELINUX
+If this variable is not set, pseudo returns always false for
+.IR is_selinux_enabled(3) .
+Programs like \fIinstall\fR or \fIsed\ \-i\fR will not try to set
+filecontexts which might fail and causing nasty sideeffects when
+running as a confined user.
+.TP 8
 .B PSEUDO_ENOSYS_ABORT
 If this variable is set, the
 .I pseudo
diff --git a/pseudo.h b/pseudo.h
index 92020e4..5be867d 100644
--- a/pseudo.h
+++ b/pseudo.h
@@ -41,6 +41,7 @@ extern unsigned long pseudo_util_debug_flags;
 extern int pseudo_util_debug_fd;
 extern int pseudo_disabled;
 extern int pseudo_allow_fsync;
+extern int pseudo_allow_selinux;
 extern int pseudo_diag(char *, ...) __attribute__ ((format (printf, 1, 2)));
 #ifndef NDEBUG
 #define pseudo_debug(x, ...) do { \
diff --git a/pseudo_client.c b/pseudo_client.c
index 8deaa1b..0951bd2 100644
--- a/pseudo_client.c
+++ b/pseudo_client.c
@@ -69,6 +69,7 @@ char *pseudo_cwd_rel = NULL;
 /* used for PSEUDO_DISABLED */
 int pseudo_disabled = 0;
 int pseudo_allow_fsync = 0;
+int pseudo_allow_selinux = 0;
 static int pseudo_local_only = 0;
 
 int pseudo_umask = 022;
@@ -188,6 +189,22 @@ pseudo_init_client(void) {
 		pseudo_allow_fsync = 0;
 	}
 
+	/* ALLOW_SELINUX is here because 'pseudo' does not emulate complete
+	 * SELinux yet.  Returning false on 'is_selinux_enabled()' makes
+	 * programs like 'install' or 'sed' behave more nicely
+	 */
+	env = getenv("PSEUDO_ALLOW_SELINUX");
+	if (!env) {
+		env = pseudo_get_value("PSEUDO_ALLOW_SELINUX");
+	} else {
+		pseudo_set_value("PSEUDO_ALLOW_SELINUX", env);
+	}
+	if (env) {
+		pseudo_allow_selinux = 1;
+	} else {
+		pseudo_allow_selinux = 0;
+	}
+
 	/* in child processes, PSEUDO_UNLOAD may become set to
 	 * some truthy value, in which case we're being asked to
 	 * remove pseudo from the LD_PRELOAD. We need to make sure
diff --git a/pseudo_util.c b/pseudo_util.c
index e4e1fc8..2a0258e 100644
--- a/pseudo_util.c
+++ b/pseudo_util.c
@@ -66,6 +66,7 @@ static struct pseudo_variables pseudo_env[] = {
 	{ "PSEUDO_DISABLED", 15, NULL },
 	{ "PSEUDO_UNLOAD", 13, NULL },
 	{ "PSEUDO_ALLOW_FSYNC", 18, NULL },
+	{ "PSEUDO_ALLOW_SELINUX", 19, NULL },
 	{ NULL, 0, NULL } /* Magic terminator */
 };
 
-- 
1.9.3

